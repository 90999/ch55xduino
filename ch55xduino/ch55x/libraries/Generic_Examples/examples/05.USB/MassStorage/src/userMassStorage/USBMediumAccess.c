#include "USBMassStorage.h"
#include "USBMediumAccess.h"

/* External variables --------------------------------------------------------*/
// Defined in USBMassStorage.c
extern __xdata Bulk_Only_CBW CBW;

//FAT info: http://www.c-jump.com/CIS24/Slides/FAT/lecture.html

__code const uint8_t diskCapacity[8]=
{
    0x00,0x00,0x4F,0xFF, //能够访问的最大逻辑块地址
    0x00,0x00,0x02,0x00  //块的长度
    //所以该磁盘的容量为
    //(0x4FFF+1)*0x200 = 0xA00000 = 10*1024*1024 = 10MB.
};

__code const uint8_t formatCapacity[8]=
{
    0x00,0x00,0x50,0x00, //能够访问的最大逻辑块地址
    0x02,0x00,0x02,0x00  //块的长度, // 02:Descriptor Code: Formatted Media
    //所以该磁盘的容量为
    //(0x4FFF+1)*0x200 = 0xA00000 = 10*1024*1024 = 10MB.
};

__xdata uint8_t emuDisk_Status = MAL_OK;

__code const uint8_t emuDisk_Inquiry_Data[] =
  {
    0x00,          /* Direct Access Device */
    0x80,          /* RMB = 1: Removable Medium */
    0x04,          /* Version: No conformance claim to standard, 4: The device complies to ANSI INCITS 351-2001 (SPC-2) */
    0x02,          /* Response Data Format = 2, The data complies with the SCSI-3 specification.*/

    0x1f,          /* Additional Length */
    0x00,          /* SCCS = 1: Storage Controller Component */
    0x00,
    0x00,
    /* Vendor Identification */
    'D', 'e', 'q', 'i', 'n', 'g', ' ', ' ',				/* Manufacturer: 8 bytes */
    /* Product Identification */
    'S', 'p', 'e', 'e', 'd', ' ', 'D', 'e',				/* Product : 16 Bytes */
		'm', 'o', 'n', ' ', ' ', ' ', ' ', ' ',
    /* Product Revision Level */
    '1', '.', '0', ' '														/* Version : 4 Bytes */
  };

__code const uint8_t DBR_data[512]={    //to be edited
    0xeb, 0x3e, 0x90,          //跳转指令，不能改为0，否则提示未格式化
    'M','S','D','O','S','5','.','0', //文件系统及版本信息"MSDOS5.0"
    0x00, 0x02,                //每扇区字节数，为512字节
    0x08,                      //每簇扇区数，为8扇区
    0x01, 0x00,                //保留扇区数，为1
    0x02,                      //该分区的FAT份数，为2
    0x00, 0x02,                //根目录项数，为512项
    0x00, 0x00,                //小扇区数，这里不用，为0
    0xF8,                      //媒体描述符，0xF8表示硬盘
    0x20, 0x00,                //每FAT扇区数，为32个
    0x20, 0x00,                //每道扇区数，为32
    0x40, 0x00,                //磁头数为64
    0x00, 0x00, 0x00, 0x00,    //隐藏扇区数这里没有隐藏扇区，为0
    0x00, 0x50, 0x00, 0x00,    //大扇区数，扇区的总数，10M为0x5000, 2560 clusters, FAT12 is less than 4087 clusters
    0x80,                      //磁盘驱动器参数，80表示硬盘
    0x00,                      //保留
    0x29,                      //扩展引导标记，0x29表示接下来的三个域可用
    0x88, 0x09, 0x71, 0x20,          //标卷序列号
    
    //磁盘标卷：圈圈的假U盘
    'S', 'p', 'e', 'e', 'd', ' ', 'D', 'e', 'm', 'o', 'n',
    
    //文件系统类型信息，为字符串"FAT12   "
    'F', 'A', 'T', '1', '2', 0x20,0x20, 0x20,
    
    //以下为引导代码，直接从其它U盘复制而来
    0xf1, 0x7d,
    0xfa, 0x33, 0xc9, 0x8e,  0xd1, 0xbc, 0xfc, 0x7b,  0x16, 0x07, 0xbd, 0x78,  0x00, 0xc5, 0x76, 0x00,
    0x1e, 0x56, 0x16, 0x55,  0xbf, 0x22, 0x05, 0x89,  0x7e, 0x00, 0x89, 0x4e,  0x02, 0xb1, 0x0b, 0xfc,
    0xf3, 0xa4, 0x06, 0x1f,  0xbd, 0x00, 0x7c, 0xc6,  0x45, 0xfe, 0x0f, 0x8b,  0x46, 0x18, 0x88, 0x45,
    0xf9, 0xfb, 0x38, 0x66,  0x24, 0x7c, 0x04, 0xcd,  0x13, 0x72, 0x3c, 0x8a,  0x46, 0x10, 0x98, 0xf7,
    0x66, 0x16, 0x03, 0x46,  0x1c, 0x13, 0x56, 0x1e,  0x03, 0x46, 0x0e, 0x13,  0xd1, 0x50, 0x52, 0x89,
    0x46, 0xfc, 0x89, 0x56,  0xfe, 0xb8, 0x20, 0x00,  0x8b, 0x76, 0x11, 0xf7,  0xe6, 0x8b, 0x5e, 0x0b,
    0x03, 0xc3, 0x48, 0xf7,  0xf3, 0x01, 0x46, 0xfc,  0x11, 0x4e, 0xfe, 0x5a,  0x58, 0xbb, 0x00, 0x07,
    0x8b, 0xfb, 0xb1, 0x01,  0xe8, 0x94, 0x00, 0x72,  0x47, 0x38, 0x2d, 0x74,  0x19, 0xb1, 0x0b, 0x56,
    0x8b, 0x76, 0x3e, 0xf3,  0xa6, 0x5e, 0x74, 0x4a,  0x4e, 0x74, 0x0b, 0x03,  0xf9, 0x83, 0xc7, 0x15,
    0x3b, 0xfb, 0x72, 0xe5,  0xeb, 0xd7, 0x2b, 0xc9,  0xb8, 0xd8, 0x7d, 0x87,  0x46, 0x3e, 0x3c, 0xd8,
    0x75, 0x99, 0xbe, 0x80,  0x7d, 0xac, 0x98, 0x03,  0xf0, 0xac, 0x84, 0xc0,  0x74, 0x17, 0x3c, 0xff,
    0x74, 0x09, 0xb4, 0x0e,  0xbb, 0x07, 0x00, 0xcd,  0x10, 0xeb, 0xee, 0xbe,  0x83, 0x7d, 0xeb, 0xe5,
    0xbe, 0x81, 0x7d, 0xeb,  0xe0, 0x33, 0xc0, 0xcd,  0x16, 0x5e, 0x1f, 0x8f,  0x04, 0x8f, 0x44, 0x02,
    0xcd, 0x19, 0xbe, 0x82,  0x7d, 0x8b, 0x7d, 0x0f,  0x83, 0xff, 0x02, 0x72,  0xc8, 0x8b, 0xc7, 0x48,
    0x48, 0x8a, 0x4e, 0x0d,  0xf7, 0xe1, 0x03, 0x46,  0xfc, 0x13, 0x56, 0xfe,  0xbb, 0x00, 0x07, 0x53,
    0xb1, 0x04, 0xe8, 0x16,  0x00, 0x5b, 0x72, 0xc8,  0x81, 0x3f, 0x4d, 0x5a,  0x75, 0xa7, 0x81, 0xbf,
    0x00, 0x02, 0x42, 0x4a,  0x75, 0x9f, 0xea, 0x00,  0x02, 0x70, 0x00, 0x50,  0x52, 0x51, 0x91, 0x92,
    0x33, 0xd2, 0xf7, 0x76,  0x18, 0x91, 0xf7, 0x76,  0x18, 0x42, 0x87, 0xca,  0xf7, 0x76, 0x1a, 0x8a,
    0xf2, 0x8a, 0x56, 0x24,  0x8a, 0xe8, 0xd0, 0xcc,  0xd0, 0xcc, 0x0a, 0xcc,  0xb8, 0x01, 0x02, 0xcd,
    0x13, 0x59, 0x5a, 0x58,  0x72, 0x09, 0x40, 0x75,  0x01, 0x42, 0x03, 0x5e,  0x0b, 0xe2, 0xcc, 0xc3,
    0x03, 0x18, 0x01, 0x27,  0x0d, 0x0a, 0x49, 0x6e,  0x76, 0x61, 0x6c, 0x69,  0x64, 0x20, 0x73, 0x79,
    0x73, 0x74, 0x65, 0x6d,  0x20, 0x64, 0x69, 0x73,  0x6b, 0xff, 0x0d, 0x0a,  0x44, 0x69, 0x73, 0x6b,
    0x20, 0x49, 0x2f, 0x4f,  0x20, 0x65, 0x72, 0x72,  0x6f, 0x72, 0xff, 0x0d,  0x0a, 0x52, 0x65, 0x70,
    0x6c, 0x61, 0x63, 0x65,  0x20, 0x74, 0x68, 0x65,  0x20, 0x64, 0x69, 0x73,  0x6b, 0x2c, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x74,  0x68, 0x65, 0x6e, 0x20,  0x70, 0x72, 0x65, 0x73,  0x73, 0x20, 0x61, 0x6e,
    0x79, 0x20, 0x6b, 0x65,  0x79, 0x0d, 0x0a, 0x00,  0x49, 0x4f, 0x20, 0x20,  0x20, 0x20, 0x20, 0x20,
    0x53, 0x59, 0x53, 0x4d,  0x53, 0x44, 0x4f, 0x53,  0x20, 0x20, 0x20, 0x53,  0x59, 0x53, 0x80, 0x01,
    0x00, 0x57, 0x49, 0x4e,  0x42, 0x4f, 0x4f, 0x54,  0x20, 0x53, 0x59, 0x53,  0x00, 0x00, 0x55, 0xaa,
 
};


//1 cluster = 32 sectors = 16KB
//模拟的文件分配表
//其中项0为0xFF8，项1为0xFFF，表示已经使用。
//项2为0xFFF，表示文件结束。其余项为0，表示未使用
//yz Zx XY, FAT12 xyz is the one pointer entry and XYZ is the second pointer entry.
__code const uint8_t FAT_data[64]={
    0xF0, 0xFF, 0xFF,
    0xFF, 0x4F, 0x00,
    0x05, 0x60, 0x00,
    0xFF, 0x0F, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00 ,0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00 ,0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,
    0x00, 0x00 ,0x00, 0x00,  0x00, 0x00, 0x00, 0x00
};


//测试文件的数据
__code const uint8_t ReadmeFileData[]=
{
    "This is a test file on speed demon.\n\r"
};


/********** 时间格式（16Bits）为： **************
 Bits15~11表示小时，可以取值为0~23；
 Bits10~5表示分，可以取值为0~59；
 Bits4~0表示秒，可以取值为0~29，每单位为2秒，即实际秒值为该值的2倍。
 */

/********* 日期格式（16Bits）为：  *************
 Bits15~9表示年份，可以取值为0~127，它表示距离1980年差值，
 即实际的年份为该值加上1980，最大可表示到2107年；
 
 Bits8~5表示月份，可以取值为1~12；
 Bits4~0表示号数，可以取值为1~31。
 */

//求出16位时间格式的高字节
#define TIME_HB(H,M,S) (((((H)<<3))|((M)>>3)))
//求出16位时间格式的低字节
#define TIME_LB(H,M,S) (((0))|((M)<<5)|(S))

//求出16位日期格式的高字节
#define DATE_HB(Y,M,D) (((((Y)-1980)<<1)|((M)>>3)))
//求出16位日期格式的低字节
#define DATE_LB(Y,M,D) ((0)|((M)<<5)|(D))

#define FILE_LEN 65536L
#define FILE_CLUSTER_LIMIT (((FILE_LEN+4095)/4096)+3)


//根目录
__code const uint8_t RootDir[96]={
    //label, match DBR
    'S', 'p', 'e', 'e', 'd', ' ', 'D', 'e', 'm', 'o', 'n',
    0x08,                  //文件属性，表示磁盘标卷
    0x00,                  //保留
    0x00,                  //创建时间毫秒时间戳, Byte 13
    
    //文件创建时间，15点27分35秒
    TIME_LB(15,27,35), TIME_HB(15,27,35),
    
    //文件创建日期，2008年8月19日
    DATE_LB(2008,8,19), DATE_HB(2008,8,19),
    
    //最后访问日期，2008年8月20日
    DATE_LB(2008,8,20), DATE_HB(2008,8,20),
    
    0x00, 0x00,            //起始簇号高位字节，FAT12/16必须为0
    
    //最后修改时间，15点36分47秒
    TIME_LB(15,36,47), TIME_HB(15,36,47),
    
    //最后修改日期，2008年8月19日
    DATE_LB(2008,8,19), DATE_HB(2008,8,19),
    
    0x00, 0x00,            //起始簇低字
    0x00, 0x00, 0x00, 0x00,   //文件长度
    
    //根目录下的测试文件
    //文件名“TEST.TXT”
    'R',  'E',   'A',  'D', 'M', 'E', ' ', ' ',  'T', 'X', 'T',
    0x01,                  //文件属性，表示只读文件
    0x00,                  //保留
    0x00,                  //创建时间毫秒时间戳
    //文件创建时间，15点48分26秒
    TIME_LB(15,48,26), TIME_HB(15,48,26),
    
    //文件创建日期,2008年8月19日
    DATE_LB(2008,8,19), DATE_HB(2008,8,19),
    
    //最后访问日期
    DATE_LB(2008,8,20), DATE_HB(2008,8,20),
    
    0x00, 0x00,            //起始簇号高位字节，FAT12/16必须为0
    
    //最后修改时间,15点50分33秒
    TIME_LB(15,50,33), TIME_HB(15,50,33),
    
    //最后修改日期，2008年8月19日
    DATE_LB(2008,8,19), DATE_HB(2008,8,19),
    
    0x02, 0x00,            //起始簇低字，簇2。  The first cluster has an address of 2. I.e., there is no addressable cluster 0 or 1
    
    //文件长度
    (sizeof(ReadmeFileData)-1),((sizeof(ReadmeFileData)-1)>>8), 0x00, 0x00,
    
    //根目录下的测试文件
    //文件名“TEST.TXT”
    'T',  'E',   'S',  'T', ' ', ' ', ' ', ' ',  'T', 'X', 'T',
    0x01,                  //文件属性，表示只读文件
    0x00,                  //保留
    0x00,                  //创建时间毫秒时间戳
    //文件创建时间，15点48分26秒
    TIME_LB(15,48,26), TIME_HB(15,48,26),
    
    //文件创建日期,2008年8月19日
    DATE_LB(2008,8,19), DATE_HB(2008,8,19),
    
    //最后访问日期
    DATE_LB(2008,8,20), DATE_HB(2008,8,20),
    
    0x00, 0x00,            //起始簇号高位字节，FAT12/16必须为0
    
    //最后修改时间,15点50分33秒
    TIME_LB(15,50,33), TIME_HB(15,50,33),
    
    //最后修改日期，2008年8月19日
    DATE_LB(2008,8,19), DATE_HB(2008,8,19),
    
    0x03, 0x00,            //起始簇低字，簇3。  The first cluster has an address of 2. I.e., there is no addressable cluster 0 or 1
    
    //文件长度
//    (sizeof(TestFileData)-1),((sizeof(TestFileData)-1)>>8), 0x00, 0x00,
    ((FILE_LEN)&0xFF),((FILE_LEN>>8)&0xFF), ((FILE_LEN>>16)&0xFF), ((FILE_LEN>>24)&0xFF),   //511 sector*4KB. Each byte in flash takes 4 bytes to display

};





uint8_t LUN_GetStatus () {
    return emuDisk_Status;
}


void LUN_Eject () {
    emuDisk_Status = MAL_FAIL;
}
